(function(){function require(e,t){for(var n=[],r=e.split("/"),i,s,o=0;s=r[o++];)".."==s?n.pop():"."!=s&&n.push(s);n=n.join("/"),o=require,s=o.m[t||0],i=s[n+".js"]||s[n+"/index.js"]||s[n];if(s=i.c)i=o.m[t=s][e=i.m];return i.exports||i(i,i.exports={},function(n){return o("."!=n.charAt(0)?n:e+"/../"+n,t)}),i.exports};
require.m = [];
require.m[0] = { "adaptive_card_formatter.js": function(module, exports, require){// Generated by CoffeeScript 1.4.0
(function() {
  var AMEX, AdaptiveCardFormatter, AmexCardFormatter, DefaultCardFormatter, determineCardType, _ref;

  AmexCardFormatter = require('./amex_card_formatter');

  DefaultCardFormatter = require('./default_card_formatter');

  _ref = require('./card_utils'), determineCardType = _ref.determineCardType, AMEX = _ref.AMEX;

  AdaptiveCardFormatter = (function() {

    function AdaptiveCardFormatter() {
      this.amexCardFormatter = new AmexCardFormatter();
      this.defaultCardFormatter = new DefaultCardFormatter();
      this.formatter = this.defaultCardFormatter;
    }

    AdaptiveCardFormatter.prototype.format = function(pan) {
      return this.formatter.format(pan);
    };

    AdaptiveCardFormatter.prototype.parse = function(text, error) {
      return this.formatter.parse(text, error);
    };

    AdaptiveCardFormatter.prototype.isChangeValid = function(change) {
      if (determineCardType(change.proposed.text.replace(/[^\d]+/g, '')) === AMEX) {
        this.formatter = this.amexCardFormatter;
      } else {
        this.formatter = this.defaultCardFormatter;
      }
      return this.formatter.isChangeValid(change);
    };

    return AdaptiveCardFormatter;

  })();

  module.exports = AdaptiveCardFormatter;

}).call(this);
},
"amex_card_formatter.js": function(module, exports, require){// Generated by CoffeeScript 1.4.0
(function() {
  var AmexCardFormatter, DefaultCardFormatter,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  DefaultCardFormatter = require('./default_card_formatter');

  AmexCardFormatter = (function(_super) {

    __extends(AmexCardFormatter, _super);

    function AmexCardFormatter() {
      return AmexCardFormatter.__super__.constructor.apply(this, arguments);
    }

    AmexCardFormatter.prototype.maximumLength = 15 + 2;

    AmexCardFormatter.prototype.hasDelimiterAtIndex = function(index) {
      return index === 4 || index === 11;
    };

    return AmexCardFormatter;

  })(DefaultCardFormatter);

  module.exports = AmexCardFormatter;

}).call(this);
},
"card_text_field.js": function(module, exports, require){// Generated by CoffeeScript 1.4.0
(function() {
  var AdaptiveCardFormatter, CardTextField, TextField, determineCardType,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  TextField = require('./text_field');

  AdaptiveCardFormatter = require('./adaptive_card_formatter');

  determineCardType = require('./card_utils').determineCardType;

  CardTextField = (function(_super) {

    __extends(CardTextField, _super);

    function CardTextField(element) {
      CardTextField.__super__.constructor.call(this, element);
      this.setFormatter(new AdaptiveCardFormatter());
    }

    CardTextField.prototype.cardType = function() {
      return determineCardType(this.value());
    };

    return CardTextField;

  })(TextField);

  module.exports = CardTextField;

}).call(this);
},
"card_utils.js": function(module, exports, require){// Generated by CoffeeScript 1.4.0
(function() {
  var AMEX, DISCOVER, MASTERCARD, VISA, determineCardType, luhnCheck, validCardLength;

  AMEX = 'amex';

  DISCOVER = 'discover';

  MASTERCARD = 'mastercard';

  VISA = 'visa';

  determineCardType = function(pan) {
    var firsttwo, halfiin, iin;
    if (pan == null) {
      return null;
    }
    pan = pan.toString();
    firsttwo = parseInt(pan.slice(0, 2), 10);
    iin = parseInt(pan.slice(0, 6), 10);
    halfiin = parseInt(pan.slice(0, 3), 10);
    if (pan[0] === '4') {
      return VISA;
    } else if (pan.slice(0, 4) === '6011' || firsttwo === 65 || (halfiin >= 664 && halfiin <= 649) || (iin >= 622126 && iin <= 622925)) {
      return DISCOVER;
    } else if (firsttwo >= 51 && firsttwo <= 55) {
      return MASTERCARD;
    } else if (firsttwo === 34 || firsttwo === 37) {
      return AMEX;
    }
  };

  luhnCheck = function(pan) {
    var digit, flip, i, sum, _i, _ref;
    sum = 0;
    flip = true;
    for (i = _i = _ref = pan.length - 1; _ref <= 0 ? _i <= 0 : _i >= 0; i = _ref <= 0 ? ++_i : --_i) {
      if (!(pan.charAt(i) !== ' ')) {
        continue;
      }
      digit = parseInt(pan.charAt(i), 10);
      sum += (flip = !flip) ? Math.floor((digit * 2) / 10) + Math.floor(digit * 2 % 10) : digit;
    }
    return sum % 10 === 0;
  };

  validCardLength = function(pan) {
    var _ref;
    switch (determineCardType(pan)) {
      case VISA:
        return (_ref = pan.length) === 13 || _ref === 16;
      case DISCOVER:
      case MASTERCARD:
        return pan.length === 16;
      case AMEX:
        return pan.length === 15;
      default:
        return false;
    }
  };

  module.exports = {
    determineCardType: determineCardType,
    luhnCheck: luhnCheck,
    validCardLength: validCardLength,
    AMEX: AMEX,
    DISCOVER: DISCOVER,
    MASTERCARD: MASTERCARD,
    VISA: VISA
  };

}).call(this);
},
"default_card_formatter.js": function(module, exports, require){// Generated by CoffeeScript 1.4.0
(function() {
  var DefaultCardFormatter, DelimitedTextFormatter, luhnCheck, validCardLength, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  DelimitedTextFormatter = require('./delimited_text_formatter');

  _ref = require('./card_utils'), validCardLength = _ref.validCardLength, luhnCheck = _ref.luhnCheck;

  DefaultCardFormatter = (function(_super) {

    __extends(DefaultCardFormatter, _super);

    function DefaultCardFormatter() {
      return DefaultCardFormatter.__super__.constructor.apply(this, arguments);
    }

    DefaultCardFormatter.prototype.delimiter = ' ';

    DefaultCardFormatter.prototype.maximumLength = 16 + 3;

    DefaultCardFormatter.prototype.hasDelimiterAtIndex = function(index) {
      return index === 4 || index === 9 || index === 14;
    };

    DefaultCardFormatter.prototype.parse = function(text, error) {
      var value;
      value = this._valueFromText(text);
      if (!validCardLength(value)) {
        if (typeof error === "function") {
          error('card-formatter.number-too-short');
        }
      }
      if (!luhnCheck(value)) {
        if (typeof error === "function") {
          error('card-formatter.invalid-number');
        }
      }
      return DefaultCardFormatter.__super__.parse.call(this, text, error);
    };

    DefaultCardFormatter.prototype._valueFromText = function(text) {
      return DefaultCardFormatter.__super__._valueFromText.call(this, (text != null ? text : '').replace(/[^\d]/g, ''));
    };

    return DefaultCardFormatter;

  })(DelimitedTextFormatter);

  module.exports = DefaultCardFormatter;

}).call(this);
},
"delimited_text_formatter.js": function(module, exports, require){// Generated by CoffeeScript 1.4.0
(function() {
  var DelimitedTextFormatter, Formatter,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  Formatter = require('./formatter');

  DelimitedTextFormatter = (function(_super) {

    __extends(DelimitedTextFormatter, _super);

    DelimitedTextFormatter.prototype.delimiter = null;

    function DelimitedTextFormatter(delimiter) {
      var _ref;
      if (delimiter == null) {
        delimiter = this.delimiter;
      }
      this.delimiter = delimiter;
      if (((_ref = this.delimiter) != null ? _ref.length : void 0) !== 1) {
        throw new Error('delimiter must have just one character');
      }
    }

    DelimitedTextFormatter.prototype.format = function(value) {
      return this._textFromValue(value);
    };

    DelimitedTextFormatter.prototype._textFromValue = function(value) {
      var char, result, _i, _len;
      if (!value) {
        return '';
      }
      result = '';
      for (_i = 0, _len = value.length; _i < _len; _i++) {
        char = value[_i];
        if (this.hasDelimiterAtIndex(result.length)) {
          result += this.delimiter;
        }
        result += char;
        if (this.hasDelimiterAtIndex(result.length)) {
          result += this.delimiter;
        }
      }
      return result;
    };

    DelimitedTextFormatter.prototype.parse = function(text, error) {
      return this._valueFromText(text);
    };

    DelimitedTextFormatter.prototype._valueFromText = function(text) {
      var char;
      if (!text) {
        return '';
      }
      return ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = text.length; _i < _len; _i++) {
          char = text[_i];
          if (char !== this.delimiter) {
            _results.push(char);
          }
        }
        return _results;
      }).call(this)).join('');
    };

    DelimitedTextFormatter.prototype.isChangeValid = function(change, error) {
      var endMovedLeft, hasSelection, isChangeValid, newText, range, startMovedLeft, value;
      if (!DelimitedTextFormatter.__super__.isChangeValid.call(this, change, error)) {
        return false;
      }
      newText = change.proposed.text;
      if (change.deleted.text === this.delimiter) {
        newText = newText.substring(0, change.deleted.start - 1) + newText.substring(change.deleted.end - 1);
      }
      range = change.proposed.selectedRange;
      hasSelection = range.length !== 0;
      startMovedLeft = range.start < change.current.selectedRange.start;
      endMovedLeft = (range.start + range.length) < (change.current.selectedRange.start + change.current.selectedRange.length);
      if (this.hasDelimiterAtIndex(range.start)) {
        if (startMovedLeft) {
          range.start--;
          range.length++;
        } else {
          range.start++;
          range.length--;
        }
      }
      if (hasSelection) {
        if (this.hasDelimiterAtIndex(range.start + range.length - 1)) {
          if (startMovedLeft || endMovedLeft) {
            range.length--;
          } else {
            range.length++;
          }
        }
      } else {
        range.length = 0;
      }
      isChangeValid = true;
      value = this._valueFromText(newText, function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        isChangeValid = false;
        return error.apply(null, args);
      });
      if (isChangeValid) {
        change.proposed.text = this._textFromValue(value);
      }
      return isChangeValid;
    };

    return DelimitedTextFormatter;

  })(Formatter);

  module.exports = DelimitedTextFormatter;

}).call(this);
},
"expiry_date_formatter.js": function(module, exports, require){// Generated by CoffeeScript 1.4.0
(function() {
  var DelimitedTextFormatter, ExpiryDateFormatter, zpad2,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  DelimitedTextFormatter = require('./delimited_text_formatter');

  zpad2 = function(n) {
    var result;
    result = "" + n;
    while (result.length < 2) {
      result = "0" + result;
    }
    return result;
  };

  ExpiryDateFormatter = (function(_super) {

    __extends(ExpiryDateFormatter, _super);

    function ExpiryDateFormatter() {
      return ExpiryDateFormatter.__super__.constructor.apply(this, arguments);
    }

    ExpiryDateFormatter.prototype.delimiter = '/';

    ExpiryDateFormatter.prototype.maximumLength = 5;

    ExpiryDateFormatter.prototype.hasDelimiterAtIndex = function(index) {
      return index === 2;
    };

    ExpiryDateFormatter.prototype.format = function(value) {
      var month, year;
      if (!value) {
        return '';
      }
      month = value.month, year = value.year;
      year = year % 100;
      return ExpiryDateFormatter.__super__.format.call(this, zpad2(month) + zpad2(year));
    };

    ExpiryDateFormatter.prototype.parse = function(text, error) {
      var match;
      text = ExpiryDateFormatter.__super__.parse.call(this, text);
      if (match = text.match(/^(0?[1-9]|1\d)(\d\d)$/)) {
        return {
          month: Number(match[1]),
          year: Number(match[2])
        };
      } else {
        error('expiry-date-formatter.invalid-date');
        return null;
      }
    };

    ExpiryDateFormatter.prototype.isChangeValid = function(change, error) {
      var isBackspace, match, newText;
      isBackspace = change.proposed.text.length < change.current.text.length;
      newText = change.proposed.text;
      if (isBackspace) {
        if (change.deleted.text === this.delimiter) {
          newText = newText[0];
        }
        if (newText === '0') {
          newText = '';
        }
      } else if (change.inserted.text === this.delimiter && change.current.text === '1') {
        newText = "01" + this.delimiter;
      } else if (change.inserted.text.length > 0 && !/^\d$/.test(change.inserted.text)) {
        error('expiry-date-formatter.only-digits-allowed');
        return false;
      } else {
        if (/^[2-9]$/.test(newText)) {
          newText = '0' + newText;
        }
        if (/^1[3-9]$/.test(newText)) {
          error('expiry-date-formatter.invalid-month');
          return false;
        }
        if (newText === '00') {
          error('expiry-date-formatter.invalid-month');
          return false;
        }
        if (/^(0[1-9]|1[0-2])$/.test(newText)) {
          newText += this.delimiter;
        }
        if ((match = newText.match(/^(\d\d)(.)(\d\d?).*$/)) && match[2] === this.delimiter) {
          newText = match[1] + this.delimiter + match[3];
        }
      }
      change.proposed.text = newText;
      change.proposed.selectedRange = {
        start: newText.length,
        length: 0
      };
      return true;
    };

    return ExpiryDateFormatter;

  })(DelimitedTextFormatter);

  module.exports = ExpiryDateFormatter;

}).call(this);
},
"formatter.js": function(module, exports, require){// Generated by CoffeeScript 1.4.0
(function() {
  var Formatter;

  Formatter = (function() {

    function Formatter() {}

    Formatter.prototype.maximumLength = null;

    Formatter.prototype.format = function(text) {
      if (text == null) {
        text = '';
      }
      if (this.maximumLength != null) {
        text = text.substring(0, this.maximumLength);
      }
      return text;
    };

    Formatter.prototype.parse = function(text, error) {
      if (text == null) {
        text = '';
      }
      if (this.maximumLength != null) {
        text = text.substring(0, this.maximumLength);
      }
      return text;
    };

    Formatter.prototype.isChangeValid = function(change, error) {
      var available, newText, selectedRange, text, truncatedLength, _ref;
      _ref = change.proposed, selectedRange = _ref.selectedRange, text = _ref.text;
      if ((this.maximumLength != null) && text.length > this.maximumLength) {
        available = this.maximumLength - (text.length - change.inserted.text.length);
        newText = change.current.text.substring(0, change.current.selectedRange.start);
        if (available > 0) {
          newText += change.inserted.text.substring(0, available);
        }
        newText += change.current.text.substring(change.current.selectedRange.start + change.current.selectedRange.length);
        truncatedLength = text.length - newText.length;
        change.proposed.text = newText;
        selectedRange.start -= truncatedLength;
      }
      return true;
    };

    return Formatter;

  })();

  module.exports = Formatter;

}).call(this);
},
"index.js": function(module, exports, require){// Generated by CoffeeScript 1.4.0
(function() {
  var FieldKit;

  FieldKit = {
    AdaptiveCardFormatter: require('./adaptive_card_formatter'),
    AmexCardFormatter: require('./amex_card_formatter'),
    CardTextField: require('./card_text_field'),
    DefaultCardFormatter: require('./default_card_formatter'),
    DelimitedTextFormatter: require('./delimited_text_formatter'),
    ExpiryDateFormatter: require('./expiry_date_formatter'),
    Formatter: require('./formatter'),
    SocialSecurityNumberFormatter: require('./social_security_number_formatter'),
    TextField: require('./text_field'),
    UndoManager: require('./undo_manager')
  };

  module.exports = FieldKit;

}).call(this);
},
"social_security_number_formatter.js": function(module, exports, require){// Generated by CoffeeScript 1.4.0
(function() {
  var DelimitedTextFormatter, SocialSecurityNumberFormatter,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  DelimitedTextFormatter = require('./delimited_text_formatter');

  SocialSecurityNumberFormatter = (function(_super) {

    __extends(SocialSecurityNumberFormatter, _super);

    function SocialSecurityNumberFormatter() {
      return SocialSecurityNumberFormatter.__super__.constructor.apply(this, arguments);
    }

    SocialSecurityNumberFormatter.prototype.delimiter = '-';

    SocialSecurityNumberFormatter.prototype.maximumLength = 9 + 2;

    SocialSecurityNumberFormatter.prototype.hasDelimiterAtIndex = function(index) {
      return index === 3 || index === 6;
    };

    SocialSecurityNumberFormatter.prototype.isChangeValid = function(change) {
      if (/^\d*$/.test(change.inserted.text)) {
        return SocialSecurityNumberFormatter.__super__.isChangeValid.call(this, change);
      } else {
        return false;
      }
    };

    return SocialSecurityNumberFormatter;

  })(DelimitedTextFormatter);

  module.exports = SocialSecurityNumberFormatter;

}).call(this);
},
"text_field.js": function(module, exports, require){// Generated by CoffeeScript 1.4.0
(function() {
  var AFFINITY, KEYS, TextField, TextFieldStateChange, UndoManager, XPATH_FOCUSABLE_FIELD, XPATH_LOWER_CASE, findFieldFollowing, findFieldPreceding, isWordChar, makeFirstResponder,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = [].slice;

  UndoManager = require('./undo_manager');

  KEYS = {
    A: 65,
    Y: 89,
    Z: 90,
    ZERO: 48,
    NINE: 57,
    LEFT: 37,
    RIGHT: 39,
    UP: 38,
    DOWN: 40,
    BACKSPACE: 8,
    DELETE: 46,
    TAB: 9,
    ENTER: 13
  };

  KEYS.isDigit = function(keyCode) {
    return (this.ZERO <= keyCode && keyCode <= this.NINE);
  };

  KEYS.isDirectional = function(keyCode) {
    return keyCode === this.LEFT || keyCode === this.RIGHT || keyCode === this.UP || keyCode === this.DOWN;
  };

  AFFINITY = {
    UPSTREAM: 0,
    DOWNSTREAM: 1,
    NONE: null
  };

  isWordChar = function(char) {
    return char && /^\w$/.test(char);
  };

  XPATH_LOWER_CASE = function(expr) {
    return "translate(" + expr + ", \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", \"abcdefghijklmnopqrstuvwxyz\")";
  };

  XPATH_FOCUSABLE_FIELD = "*[" + (XPATH_LOWER_CASE('name(.)')) + "=\"input\" or " + (XPATH_LOWER_CASE('name(.)')) + "=\"select\"][not(type=\"hidden\")][not(contains(@class, \"field-kit-text-field-interceptor\"))]";

  findFieldFollowing = function(element) {
    var result;
    result = document.evaluate("following::" + XPATH_FOCUSABLE_FIELD, element, null, XPathResult.ANY_TYPE, null);
    return result.iterateNext();
  };

  findFieldPreceding = function(element) {
    var result;
    result = document.evaluate("preceding::" + XPATH_FOCUSABLE_FIELD, element, null, XPathResult.ANY_TYPE, null);
    return result.iterateNext();
  };

  makeFirstResponder = function(field, event) {
    var textField;
    if (textField = field.data('field-kit-text-field')) {
      return textField.becomeFirstResponder(event);
    } else {
      if (typeof field.focus === "function") {
        field.focus();
      }
      return typeof field.select === "function" ? field.select() : void 0;
    }
  };

  TextField = (function() {

    TextField.prototype.selectionAffinity = AFFINITY.NONE;

    TextField.prototype._delegate = null;

    TextField.prototype.delegate = function() {
      return this._delegate;
    };

    TextField.prototype.setDelegate = function(delegate) {
      this._delegate = delegate;
      return null;
    };

    function TextField(element) {
      this.element = element;
      this._blur = __bind(this._blur, this);

      this._focus = __bind(this._focus, this);

      this.click = __bind(this.click, this);

      this.paste = __bind(this.paste, this);

      this.keyUp = __bind(this.keyUp, this);

      this.keyPress = __bind(this.keyPress, this);

      this.keyDown = __bind(this.keyDown, this);

      this.afterInterceptorKeyUp = __bind(this.afterInterceptorKeyUp, this);

      this.beforeInterceptorKeyUp = __bind(this.beforeInterceptorKeyUp, this);

      this._jQuery = this.element.constructor;
      this.element.on('keydown', this.keyDown);
      this.element.on('keypress', this.keyPress);
      this.element.on('keyup', this.keyUp);
      this.element.on('click', this.click);
      this.element.on('paste', this.paste);
      this.element.on('focus', this._focus);
      this.element.on('blur', this._blur);
      this.element.data('field-kit-text-field', this);
      this.createTabInterceptors();
    }

    TextField.prototype.createTabInterceptors = function() {
      var afterInterceptor, beforeInterceptor, createInterceptor, input;
      input = this.element.get(0);
      createInterceptor = function() {
        var interceptor;
        interceptor = input.ownerDocument.createElement('input');
        interceptor.style.position = 'absolute';
        interceptor.style.top = '0';
        interceptor.style.left = '0';
        interceptor.style.opacity = 0;
        interceptor.style.zIndex = -9999;
        interceptor.style.pointerEvents = 'none';
        interceptor.className = 'field-kit-text-field-interceptor';
        return interceptor;
      };
      beforeInterceptor = createInterceptor();
      beforeInterceptor.onkeyup = this.beforeInterceptorKeyUp;
      input.parentNode.insertBefore(beforeInterceptor, input);
      afterInterceptor = createInterceptor();
      afterInterceptor.onkeyup = this.afterInterceptorKeyUp;
      if (input.nextSibling) {
        return input.parentNode.insertBefore(afterInterceptor, input.nextSibling);
      } else {
        return input.parentNode.appendChild(afterInterceptor);
      }
    };

    TextField.prototype.beforeInterceptorKeyUp = function(event) {
      var previousField;
      if (event.keyCode === KEYS.TAB && event.shiftKey) {
        if (previousField = findFieldPreceding(event.target)) {
          return makeFirstResponder(this._jQuery(previousField));
        }
      }
    };

    TextField.prototype.afterInterceptorKeyUp = function(event) {
      var nextField;
      if (event.keyCode === KEYS.TAB && !event.shiftKey) {
        if (nextField = findFieldFollowing(event.target)) {
          return makeFirstResponder(this._jQuery(nextField));
        }
      }
    };

    TextField.prototype.insertText = function(text) {
      var range;
      if (this.hasSelection()) {
        this.clearSelection();
      }
      this.replaceSelection(text);
      range = this.selectedRange();
      range.start += range.length;
      range.length = 0;
      return this.setSelectedRange(range);
    };

    TextField.prototype.insertNewline = function(event) {
      var _ref;
      return (_ref = this._delegate) != null ? typeof _ref.textFieldDidEndEditing === "function" ? _ref.textFieldDidEndEditing(this) : void 0 : void 0;
    };

    TextField.prototype.moveUp = function(event) {
      event.preventDefault();
      return this.setSelectedRange({
        start: 0,
        length: 0
      });
    };

    TextField.prototype.moveToBeginningOfParagraph = function(event) {
      return this.moveUp(event);
    };

    TextField.prototype.moveUpAndModifySelection = function(event) {
      var range;
      event.preventDefault();
      range = this.selectedRange();
      switch (this.selectionAffinity) {
        case AFFINITY.UPSTREAM:
        case AFFINITY.NONE:
          range.length += range.start;
          range.start = 0;
          break;
        case AFFINITY.DOWNSTREAM:
          range.length = range.start;
          range.start = 0;
      }
      return this.setSelectedRangeWithAffinity(range, AFFINITY.UPSTREAM);
    };

    TextField.prototype.moveParagraphBackwardAndModifySelection = function(event) {
      var range;
      event.preventDefault();
      range = this.selectedRange();
      switch (this.selectionAffinity) {
        case AFFINITY.UPSTREAM:
        case AFFINITY.NONE:
          range.length += range.start;
          range.start = 0;
          break;
        case AFFINITY.DOWNSTREAM:
          range.length = 0;
      }
      return this.setSelectedRangeWithAffinity(range, AFFINITY.UPSTREAM);
    };

    TextField.prototype.moveToBeginningOfDocument = function(event) {
      return this.moveToBeginningOfLine(event);
    };

    TextField.prototype.moveToBeginningOfDocumentAndModifySelection = function(event) {
      var range;
      event.preventDefault();
      range = this.selectedRange();
      range.length += range.start;
      range.start = 0;
      return this.setSelectedRangeWithAffinity(range, AFFINITY.UPSTREAM);
    };

    TextField.prototype.moveDown = function(event) {
      var range;
      event.preventDefault();
      range = {
        start: this.text().length,
        length: 0
      };
      return this.setSelectedRangeWithAffinity(range, AFFINITY.NONE);
    };

    TextField.prototype.moveToEndOfParagraph = function(event) {
      return this.moveDown(event);
    };

    TextField.prototype.moveDownAndModifySelection = function(event) {
      var end, range;
      event.preventDefault();
      range = this.selectedRange();
      end = this.text().length;
      if (this.selectionAffinity === AFFINITY.UPSTREAM) {
        range.start += range.length;
      }
      range.length = end - range.start;
      return this.setSelectedRangeWithAffinity(range, AFFINITY.DOWNSTREAM);
    };

    TextField.prototype.moveParagraphForwardAndModifySelection = function(event) {
      var range;
      event.preventDefault();
      range = this.selectedRange();
      switch (this.selectionAffinity) {
        case AFFINITY.DOWNSTREAM:
        case AFFINITY.NONE:
          range.length = this.text().length - range.start;
          break;
        case AFFINITY.UPSTREAM:
          range.start += range.length;
          range.length = 0;
      }
      return this.setSelectedRangeWithAffinity(range, AFFINITY.DOWNSTREAM);
    };

    TextField.prototype.moveToEndOfDocument = function(event) {
      return this.moveToEndOfLine(event);
    };

    TextField.prototype.moveToEndOfDocumentAndModifySelection = function(event) {
      var range;
      event.preventDefault();
      range = this.selectedRange();
      range.length = this.text().length - range.start;
      return this.setSelectedRangeWithAffinity(range, AFFINITY.DOWNSTREAM);
    };

    TextField.prototype.moveLeft = function(event) {
      var range;
      event.preventDefault();
      range = this.selectedRange();
      if (range.length !== 0) {
        range.length = 0;
      } else {
        range.start--;
      }
      return this.setSelectedRangeWithAffinity(range, AFFINITY.NONE);
    };

    TextField.prototype.moveLeftAndModifySelection = function(event) {
      var range;
      event.preventDefault();
      range = this.selectedRange();
      switch (this.selectionAffinity) {
        case AFFINITY.UPSTREAM:
        case AFFINITY.NONE:
          this.selectionAffinity = AFFINITY.UPSTREAM;
          range.start--;
          range.length++;
          break;
        case AFFINITY.DOWNSTREAM:
          range.length--;
      }
      return this.setSelectedRange(range);
    };

    TextField.prototype.moveWordLeft = function(event) {
      var index;
      event.preventDefault();
      index = this.lastWordBreakBeforeIndex(this.selectedRange().start - 1);
      return this.setSelectedRange({
        start: index,
        length: 0
      });
    };

    TextField.prototype.moveWordLeftAndModifySelection = function(event) {
      var end, range, start;
      event.preventDefault();
      range = this.selectedRange();
      switch (this.selectionAffinity) {
        case AFFINITY.UPSTREAM:
        case AFFINITY.NONE:
          this.selectionAffinity = AFFINITY.UPSTREAM;
          start = this.lastWordBreakBeforeIndex(range.start - 1);
          range.length += range.start - start;
          range.start = start;
          break;
        case AFFINITY.DOWNSTREAM:
          end = this.lastWordBreakBeforeIndex(range.start + range.length);
          if (end < range.start) {
            end = range.start;
          }
          range.length -= range.start + range.length - end;
      }
      return this.setSelectedRange(range);
    };

    TextField.prototype.moveToBeginningOfLine = function(event) {
      event.preventDefault();
      return this.setSelectedRange({
        start: 0,
        length: 0
      });
    };

    TextField.prototype.moveToBeginningOfLineAndModifySelection = function(event) {
      var range;
      event.preventDefault();
      range = this.selectedRange();
      range.length += range.start;
      range.start = 0;
      return this.setSelectedRangeWithAffinity(range, AFFINITY.UPSTREAM);
    };

    TextField.prototype.moveRight = function(event) {
      var range;
      event.preventDefault();
      range = this.selectedRange();
      if (range.length !== 0) {
        range.start += range.length;
        range.length = 0;
      } else {
        range.start++;
      }
      return this.setSelectedRangeWithAffinity(range, AFFINITY.NONE);
    };

    TextField.prototype.moveRightAndModifySelection = function(event) {
      var range;
      event.preventDefault();
      range = this.selectedRange();
      switch (this.selectionAffinity) {
        case AFFINITY.UPSTREAM:
          range.start++;
          range.length--;
          break;
        case AFFINITY.DOWNSTREAM:
        case AFFINITY.NONE:
          this.selectionAffinity = AFFINITY.DOWNSTREAM;
          range.length++;
      }
      return this.setSelectedRange(range);
    };

    TextField.prototype.moveWordRight = function(event) {
      var index, range;
      event.preventDefault();
      range = this.selectedRange();
      index = this.nextWordBreakAfterIndex(range.start + range.length);
      return this.setSelectedRange({
        start: index,
        length: 0
      });
    };

    TextField.prototype.moveWordRightAndModifySelection = function(event) {
      var end, range, start;
      event.preventDefault();
      range = this.selectedRange();
      start = range.start;
      end = range.start + range.length;
      switch (this.selectionAffinity) {
        case AFFINITY.UPSTREAM:
          start = Math.min(this.nextWordBreakAfterIndex(start), end);
          break;
        case AFFINITY.DOWNSTREAM:
        case AFFINITY.NONE:
          this.selectionAffinity = AFFINITY.DOWNSTREAM;
          end = this.nextWordBreakAfterIndex(range.start + range.length);
      }
      return this.setSelectedRange({
        start: start,
        length: end - start
      });
    };

    TextField.prototype.moveToEndOfLine = function(event) {
      event.preventDefault();
      return this.setSelectedRange({
        start: this.text().length,
        length: 0
      });
    };

    TextField.prototype.moveToEndOfLineAndModifySelection = function(event) {
      var range;
      event.preventDefault();
      range = this.selectedRange();
      range.length = this.text().length - range.start;
      return this.setSelectedRangeWithAffinity(range, AFFINITY.DOWNSTREAM);
    };

    TextField.prototype.deleteBackward = function(event) {
      var range;
      event.preventDefault();
      range = this.selectedRange();
      if (range.length === 0) {
        range.start--;
        range.length++;
        this.setSelectedRange(range);
      }
      return this.clearSelection();
    };

    TextField.prototype.deleteWordBackward = function(event) {
      var range, start;
      if (this.hasSelection()) {
        return this.deleteBackward(event);
      }
      event.preventDefault();
      range = this.selectedRange();
      start = this.lastWordBreakBeforeIndex(range.start);
      range.length += range.start - start;
      range.start = start;
      this.setSelectedRange(range);
      return this.clearSelection();
    };

    TextField.prototype.deleteBackwardByDecomposingPreviousCharacter = function(event) {
      return this.deleteBackward(event);
    };

    TextField.prototype.deleteBackwardToBeginningOfLine = function(event) {
      var range;
      if (this.hasSelection()) {
        return this.deleteBackward(event);
      }
      event.preventDefault();
      range = this.selectedRange();
      range.length = range.start;
      range.start = 0;
      this.setSelectedRange(range);
      return this.clearSelection();
    };

    TextField.prototype.deleteForward = function(event) {
      var range;
      event.preventDefault();
      range = this.selectedRange();
      if (range.length === 0) {
        range.length++;
        this.setSelectedRange(range);
      }
      return this.clearSelection();
    };

    TextField.prototype.deleteWordForward = function(event) {
      var end, range;
      if (this.hasSelection()) {
        return this.deleteForward(event);
      }
      event.preventDefault();
      range = this.selectedRange();
      end = this.nextWordBreakAfterIndex(range.start + range.length);
      this.setSelectedRange({
        start: range.start,
        length: end - range.start
      });
      return this.clearSelection();
    };

    TextField.prototype.insertTab = function(event) {};

    TextField.prototype.insertBackTab = function(event) {};

    TextField.prototype.hasSelection = function() {
      return this.selectedRange().length !== 0;
    };

    TextField.prototype.lastWordBreakBeforeIndex = function(index) {
      var indexes, result, wordBreakIndex, _i, _len;
      indexes = this.leftWordBreakIndexes();
      result = indexes[0];
      for (_i = 0, _len = indexes.length; _i < _len; _i++) {
        wordBreakIndex = indexes[_i];
        if (index > wordBreakIndex) {
          result = wordBreakIndex;
        } else {
          break;
        }
      }
      return result;
    };

    TextField.prototype.leftWordBreakIndexes = function() {
      var i, result, text, _i, _ref;
      result = [];
      text = this.text();
      for (i = _i = 0, _ref = text.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (!isWordChar(text[i - 1]) && isWordChar(text[i])) {
          result.push(i);
        }
      }
      return result;
    };

    TextField.prototype.nextWordBreakAfterIndex = function(index) {
      var indexes, result, wordBreakIndex, _i, _len;
      indexes = this.rightWordBreakIndexes().reverse();
      result = indexes[0];
      for (_i = 0, _len = indexes.length; _i < _len; _i++) {
        wordBreakIndex = indexes[_i];
        if (index < wordBreakIndex) {
          result = wordBreakIndex;
        } else {
          break;
        }
      }
      return result;
    };

    TextField.prototype.rightWordBreakIndexes = function() {
      var i, result, text, _i, _ref;
      result = [];
      text = this.text();
      for (i = _i = 0, _ref = text.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (isWordChar(text[i]) && !isWordChar(text[i + 1])) {
          result.push(i + 1);
        }
      }
      return result;
    };

    TextField.prototype.clearSelection = function() {
      return this.replaceSelection('');
    };

    TextField.prototype.replaceSelection = function(replacement) {
      var end, range, text;
      range = this.selectedRange();
      end = range.start + range.length;
      text = this.text();
      text = text.substring(0, range.start) + replacement + text.substring(end);
      range.length = replacement.length;
      this.setText(text);
      return this.setSelectedRangeWithAffinity(range, AFFINITY.NONE);
    };

    TextField.prototype.selectAll = function(event) {
      event.preventDefault();
      return this.setSelectedRangeWithAffinity({
        start: 0,
        length: this.text().length
      }, AFFINITY.NONE);
    };

    TextField.prototype.readSelectionFromPasteboard = function(pasteboard) {
      var range, text;
      text = pasteboard.getData('Text');
      this.replaceSelection(text);
      range = this.selectedRange();
      range.start += range.length;
      range.length = 0;
      return this.setSelectedRange(range);
    };

    TextField.prototype.keyDown = function(event) {
      var altKey, ctrlKey, keyCode, metaKey, modifiers, shiftKey,
        _this = this;
      keyCode = event.keyCode, metaKey = event.metaKey, ctrlKey = event.ctrlKey, shiftKey = event.shiftKey, altKey = event.altKey;
      modifiers = [];
      if (altKey) {
        modifiers.push('alt');
      }
      if (ctrlKey) {
        modifiers.push('ctrl');
      }
      if (metaKey) {
        modifiers.push('meta');
      }
      if (shiftKey) {
        modifiers.push('shift');
      }
      modifiers = modifiers.join('+');
      if (keyCode === KEYS.Z && (modifiers === 'meta' || modifiers === 'ctrl')) {
        if (this.undoManager().canUndo()) {
          this.undoManager().undo();
        }
        event.preventDefault();
      } else if ((keyCode === KEYS.Z && modifiers === 'meta+shift') || (keyCode === KEYS.Y && modifiers === 'ctrl')) {
        if (this.undoManager().canRedo()) {
          this.undoManager().redo();
        }
        event.preventDefault();
      }
      return this.rollbackInvalidChanges(function() {
        if ((metaKey || ctrlKey) && keyCode === KEYS.A) {
          _this.selectAll(event);
        } else if (keyCode === KEYS.LEFT) {
          switch (modifiers) {
            case '':
              _this.moveLeft(event);
              break;
            case 'alt':
              _this.moveWordLeft(event);
              break;
            case 'shift':
              _this.moveLeftAndModifySelection(event);
              break;
            case 'alt+shift':
              _this.moveWordLeftAndModifySelection(event);
              break;
            case 'meta':
              _this.moveToBeginningOfLine(event);
              break;
            case 'meta+shift':
              _this.moveToBeginningOfLineAndModifySelection(event);
              break;
            default:
              throw new Error("unhandled left+" + modifiers);
          }
        } else if (keyCode === KEYS.RIGHT) {
          switch (modifiers) {
            case '':
              _this.moveRight(event);
              break;
            case 'alt':
              _this.moveWordRight(event);
              break;
            case 'shift':
              _this.moveRightAndModifySelection(event);
              break;
            case 'alt+shift':
              _this.moveWordRightAndModifySelection(event);
              break;
            case 'meta':
              _this.moveToEndOfLine(event);
              break;
            case 'meta+shift':
              _this.moveToEndOfLineAndModifySelection(event);
              break;
            default:
              throw new Error("unhandled right+" + modifiers);
          }
        } else if (keyCode === KEYS.UP) {
          switch (modifiers) {
            case '':
              _this.moveUp(event);
              break;
            case 'alt':
              _this.moveToBeginningOfParagraph(event);
              break;
            case 'shift':
              _this.moveUpAndModifySelection(event);
              break;
            case 'alt+shift':
              _this.moveParagraphBackwardAndModifySelection(event);
              break;
            case 'meta':
              _this.moveToBeginningOfDocument(event);
              break;
            case 'meta+shift':
              _this.moveToBeginningOfDocumentAndModifySelection(event);
              break;
            default:
              throw new Error("unhandled up+" + modifiers);
          }
        } else if (keyCode === KEYS.DOWN) {
          switch (modifiers) {
            case '':
              _this.moveDown(event);
              break;
            case 'alt':
              _this.moveToEndOfParagraph(event);
              break;
            case 'shift':
              _this.moveDownAndModifySelection(event);
              break;
            case 'alt+shift':
              _this.moveParagraphForwardAndModifySelection(event);
              break;
            case 'meta':
              _this.moveToEndOfDocument(event);
              break;
            case 'meta+shift':
              _this.moveToEndOfDocumentAndModifySelection(event);
              break;
            default:
              throw new Error("unhandled down+" + modifiers);
          }
        } else if (keyCode === KEYS.BACKSPACE) {
          switch (modifiers) {
            case '':
            case 'shift':
              _this.deleteBackward(event);
              break;
            case 'alt':
            case 'alt+shift':
              _this.deleteWordBackward(event);
              break;
            case 'ctrl':
            case 'ctrl+shift':
              _this.deleteBackwardByDecomposingPreviousCharacter(event);
              break;
            case 'meta':
            case 'meta+shift':
              _this.deleteBackwardToBeginningOfLine(event);
              break;
            default:
              throw new Error("unhandled backspace+" + modifiers);
          }
        } else if (keyCode === KEYS.DELETE) {
          if (altKey) {
            _this.deleteWordForward(event);
          } else {
            _this.deleteForward(event);
          }
        } else if (keyCode === KEYS.TAB) {
          if (shiftKey) {
            _this.insertBackTab(event);
          } else {
            _this.insertTab(event);
          }
        } else if (keyCode === KEYS.ENTER) {
          _this.insertNewline(event);
        }
        return null;
      });
    };

    TextField.prototype.keyPress = function(event) {
      var _ref,
        _this = this;
      if (!event.metaKey && !event.ctrlKey && ((_ref = event.keyCode) !== KEYS.ENTER && _ref !== KEYS.TAB && _ref !== KEYS.BACKSPACE)) {
        event.preventDefault();
        return this.rollbackInvalidChanges(function() {
          return _this.insertText(String.fromCharCode(event.charCode));
        });
      }
    };

    TextField.prototype.keyUp = function(event) {
      var _this = this;
      return this.rollbackInvalidChanges(function() {
        if (event.keyCode === KEYS.TAB) {
          return _this.selectAll(event);
        }
      });
    };

    TextField.prototype.paste = function(event) {
      var _this = this;
      event.preventDefault();
      return this.rollbackInvalidChanges(function() {
        return _this.readSelectionFromPasteboard(event.originalEvent.clipboardData);
      });
    };

    TextField.prototype.rollbackInvalidChanges = function(callback) {
      var change, error, errorType, result, _ref, _ref1, _ref2;
      result = null;
      errorType = null;
      change = TextFieldStateChange.build(this, function() {
        return result = callback();
      });
      error = function(type) {
        return errorType = type;
      };
      if (typeof ((_ref = this.formatter()) != null ? _ref.isChangeValid : void 0) === 'function') {
        if (this.formatter().isChangeValid(change, error)) {
          change.recomputeDiff();
          this.setText(change.proposed.text);
          this.setSelectedRange(change.proposed.selectedRange);
        } else {
          if ((_ref1 = this.delegate()) != null) {
            if (typeof _ref1.textFieldDidFailToValidateChange === "function") {
              _ref1.textFieldDidFailToValidateChange(this, change, errorType);
            }
          }
          this.setText(change.current.text);
          this.setSelectedRange(change.current.selectedRange);
          return result;
        }
      }
      if (change.inserted.text.length || change.deleted.text.length) {
        this.undoManager().proxyFor(this)._applyChangeFromUndoManager(change);
        if ((_ref2 = this.delegate()) != null) {
          if (typeof _ref2.textDidChange === "function") {
            _ref2.textDidChange(this);
          }
        }
      }
      return result;
    };

    TextField.prototype.click = function(event) {
      return this.selectionAffinity = AFFINITY.NONE;
    };

    TextField.prototype.on = function() {
      var args, _ref;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return (_ref = this.element).on.apply(_ref, args);
    };

    TextField.prototype.off = function() {
      var args, _ref;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return (_ref = this.element).off.apply(_ref, args);
    };

    TextField.prototype.text = function() {
      return this.element.val();
    };

    TextField.prototype.setText = function(text) {
      return this.element.val(text);
    };

    TextField.prototype.value = function() {
      var value,
        _this = this;
      value = this.element.val();
      if (!this._formatter) {
        return value;
      }
      return this._formatter.parse(value, function(errorType) {
        var _ref;
        return (_ref = _this._delegate) != null ? typeof _ref.textFieldDidFailToParseString === "function" ? _ref.textFieldDidFailToParseString(_this, value, errorType) : void 0 : void 0;
      });
    };

    TextField.prototype.setValue = function(value) {
      if (this._formatter) {
        value = this._formatter.format(value);
      }
      this.element.val("" + value);
      return this.element.trigger('change');
    };

    TextField.prototype.formatter = function() {
      return this._formatter;
    };

    TextField.prototype.setFormatter = function(formatter) {
      var value;
      value = this.value();
      this._formatter = formatter;
      return this.setValue(value);
    };

    TextField.prototype.selectedRange = function() {
      var caret;
      caret = this.element.caret();
      return {
        start: caret.start,
        length: caret.end - caret.start
      };
    };

    TextField.prototype.setSelectedRange = function(range) {
      return this.setSelectedRangeWithAffinity(range, this.selectionAffinity);
    };

    TextField.prototype.setSelectedRangeWithAffinity = function(range, affinity) {
      var caret, max, min;
      min = 0;
      max = this.text().length;
      caret = {
        start: Math.max(min, Math.min(max, range.start)),
        end: Math.max(min, Math.min(max, range.start + range.length))
      };
      this.element.caret(caret);
      return this.selectionAffinity = range.length === 0 ? AFFINITY.NONE : affinity;
    };

    TextField.prototype.selectionAnchor = function() {
      var range;
      range = this.selectedRange();
      switch (this.selectionAffinity) {
        case AFFINITY.UPSTREAM:
          return range.start + range.length;
        case AFFINITY.DOWNSTREAM:
          return range.start;
        default:
          return null;
      }
    };

    TextField.prototype.undoManager = function() {
      return this._undoManager || (this._undoManager = new UndoManager());
    };

    TextField.prototype.allowsUndo = function() {
      return this._allowsUndo;
    };

    TextField.prototype.setAllowsUndo = function(allowsUndo) {
      return this._allowsUndo = allowsUndo;
    };

    TextField.prototype._applyChangeFromUndoManager = function(change) {
      this.undoManager().proxyFor(this)._applyChangeFromUndoManager(change);
      if (this.undoManager().isUndoing()) {
        this.setText(change.current.text);
        return this.setSelectedRange(change.current.selectedRange);
      } else {
        this.setText(change.proposed.text);
        return this.setSelectedRange(change.proposed.selectedRange);
      }
    };

    TextField.prototype._enabled = true;

    TextField.prototype.isEnabled = function() {
      return this._enabled;
    };

    TextField.prototype.setEnabled = function(_enabled) {
      this._enabled = _enabled;
      this._syncPlaceholder();
      return null;
    };

    TextField.prototype.hasFocus = function() {
      return this.element.get(0).ownerDocument.activeElement === this.element.get(0);
    };

    TextField.prototype._focus = function(event) {
      return this._syncPlaceholder();
    };

    TextField.prototype._blur = function(event) {
      var _ref;
      if ((_ref = this._delegate) != null) {
        if (typeof _ref.textFieldDidEndEditing === "function") {
          _ref.textFieldDidEndEditing(this);
        }
      }
      return this._syncPlaceholder();
    };

    TextField.prototype.becomeFirstResponder = function(event) {
      var _this = this;
      this.element.focus();
      return this.rollbackInvalidChanges(function() {
        _this.element.select();
        return _this._syncPlaceholder();
      });
    };

    TextField.prototype.resignFirstResponder = function(event) {
      if (event != null) {
        event.preventDefault();
      }
      this.element.blur();
      return this._syncPlaceholder();
    };

    TextField.prototype._placeholder = null;

    TextField.prototype._disabledPlaceholder = null;

    TextField.prototype._focusedPlaceholder = null;

    TextField.prototype._unfocusedPlaceholder = null;

    TextField.prototype.disabledPlaceholder = function() {
      return this._disabledPlaceholder;
    };

    TextField.prototype.setDisabledPlaceholder = function(_disabledPlaceholder) {
      this._disabledPlaceholder = _disabledPlaceholder;
      this._syncPlaceholder();
      return null;
    };

    TextField.prototype.focusedPlaceholder = function() {
      return this._focusedPlaceholder;
    };

    TextField.prototype.setFocusedPlaceholder = function(_focusedPlaceholder) {
      this._focusedPlaceholder = _focusedPlaceholder;
      this._syncPlaceholder();
      return null;
    };

    TextField.prototype.unfocusedPlaceholder = function() {
      return this._unfocusedPlaceholder;
    };

    TextField.prototype.setUnfocusedPlaceholder = function(_unfocusedPlaceholder) {
      this._unfocusedPlaceholder = _unfocusedPlaceholder;
      this._syncPlaceholder();
      return null;
    };

    TextField.prototype.placeholder = function() {
      return this._placeholder;
    };

    TextField.prototype.setPlaceholder = function(_placeholder) {
      this._placeholder = _placeholder;
      return this.element.attr('placeholder', this._placeholder);
    };

    TextField.prototype._syncPlaceholder = function() {
      if (!this._enabled) {
        if (this._disabledPlaceholder != null) {
          return this.setPlaceholder(this._disabledPlaceholder);
        }
      } else if (this.hasFocus()) {
        if (this._focusedPlaceholder != null) {
          return this.setPlaceholder(this._focusedPlaceholder);
        }
      } else {
        if (this._unfocusedPlaceholder != null) {
          return this.setPlaceholder(this._unfocusedPlaceholder);
        }
      }
    };

    TextField.prototype.inspect = function() {
      return "#<TextField text=" + (this.text()) + ">";
    };

    return TextField;

  })();

  TextFieldStateChange = (function() {

    TextFieldStateChange.prototype.field = null;

    TextFieldStateChange.prototype.current = null;

    TextFieldStateChange.prototype.proposed = null;

    function TextFieldStateChange(field) {
      this.field = field;
    }

    TextFieldStateChange.build = function(field, callback) {
      var change;
      change = new this(field);
      change.current = {
        text: field.text(),
        selectedRange: field.selectedRange()
      };
      callback();
      change.proposed = {
        text: field.text(),
        selectedRange: field.selectedRange()
      };
      change.recomputeDiff();
      return change;
    };

    TextFieldStateChange.prototype.recomputeDiff = function() {
      var ctext, deleted, i, inserted, minTextLength, ptext, sharedPrefixLength, sharedSuffixLength, _i, _j, _ref;
      if (this.proposed.text !== this.current.text) {
        ctext = this.current.text;
        ptext = this.proposed.text;
        sharedPrefixLength = 0;
        sharedSuffixLength = 0;
        minTextLength = Math.min(ctext.length, ptext.length);
        for (i = _i = 0; 0 <= minTextLength ? _i < minTextLength : _i > minTextLength; i = 0 <= minTextLength ? ++_i : --_i) {
          if (ptext[i] === ctext[i]) {
            sharedPrefixLength = i + 1;
          } else {
            break;
          }
        }
        for (i = _j = 0, _ref = minTextLength - sharedPrefixLength; 0 <= _ref ? _j < _ref : _j > _ref; i = 0 <= _ref ? ++_j : --_j) {
          if (ptext[ptext.length - 1 - i] === ctext[ctext.length - 1 - i]) {
            sharedSuffixLength = i + 1;
          } else {
            break;
          }
        }
        inserted = {
          start: sharedPrefixLength,
          end: ptext.length - sharedSuffixLength
        };
        deleted = {
          start: sharedPrefixLength,
          end: ctext.length - sharedSuffixLength
        };
        inserted.text = ptext.substring(inserted.start, inserted.end);
        deleted.text = ctext.substring(deleted.start, deleted.end);
        this.inserted = inserted;
        this.deleted = deleted;
      } else {
        this.inserted = {
          start: this.proposed.selectedRange.start,
          end: this.proposed.selectedRange.start + this.proposed.selectedRange.length,
          text: ''
        };
        this.deleted = {
          start: this.current.selectedRange.start,
          end: this.current.selectedRange.start + this.current.selectedRange.length,
          text: ''
        };
      }
      return null;
    };

    return TextFieldStateChange;

  })();

  module.exports = TextField;

}).call(this);
},
"undo_manager.js": function(module, exports, require){// Generated by CoffeeScript 1.4.0
(function() {
  var UndoManager, hasGetter,
    __slice = [].slice;

  hasGetter = function(object, property) {
    var _ref, _ref1, _ref2;
    if (object != null ? (_ref = object.constructor) != null ? _ref.prototype : void 0 : void 0) {
      if ((_ref1 = Object.getOwnPropertyDescriptor(object.constructor.prototype, property)) != null ? _ref1.get : void 0) {
        return true;
      }
    }
    return ((_ref2 = Object.getOwnPropertyDescriptor(object, property)) != null ? _ref2.get : void 0) != null;
  };

  UndoManager = (function() {

    UndoManager.prototype._undos = null;

    UndoManager.prototype._redos = null;

    UndoManager.prototype._isUndoing = false;

    UndoManager.prototype._isRedoing = false;

    function UndoManager() {
      this._undos = [];
      this._redos = [];
    }

    UndoManager.prototype.canUndo = function() {
      return this._undos.length !== 0;
    };

    UndoManager.prototype.canRedo = function() {
      return this._redos.length !== 0;
    };

    UndoManager.prototype.isUndoing = function() {
      return this._isUndoing;
    };

    UndoManager.prototype.isRedoing = function() {
      return this._isRedoing;
    };

    UndoManager.prototype.registerUndo = function() {
      var args, selector, target;
      target = arguments[0], selector = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      if (this._isUndoing) {
        this._appendRedo.apply(this, [target, selector].concat(__slice.call(args)));
      } else {
        if (!this._isRedoing) {
          this._redos.length = 0;
        }
        this._appendUndo.apply(this, [target, selector].concat(__slice.call(args)));
      }
      return null;
    };

    UndoManager.prototype._appendUndo = function() {
      var args, selector, target;
      target = arguments[0], selector = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      return this._undos.push({
        target: target,
        selector: selector,
        args: args
      });
    };

    UndoManager.prototype._appendRedo = function() {
      var args, selector, target;
      target = arguments[0], selector = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      return this._redos.push({
        target: target,
        selector: selector,
        args: args
      });
    };

    UndoManager.prototype.undo = function() {
      var args, selector, target, _ref;
      if (!this.canUndo()) {
        throw new Error('there are no registered undos');
      }
      _ref = this._undos.pop(), target = _ref.target, selector = _ref.selector, args = _ref.args;
      this._isUndoing = true;
      target[selector].apply(target, args);
      this._isUndoing = false;
      return null;
    };

    UndoManager.prototype.redo = function() {
      var args, selector, target, _ref;
      if (!this.canRedo()) {
        throw new Error('there are no registered redos');
      }
      _ref = this._redos.pop(), target = _ref.target, selector = _ref.selector, args = _ref.args;
      this._isRedoing = true;
      target[selector].apply(target, args);
      this._isRedoing = false;
      return null;
    };

    UndoManager.prototype.proxyFor = function(target) {
      var proxy, selector, _fn,
        _this = this;
      proxy = {};
      _fn = function(selector) {
        return proxy[selector] = function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return _this.registerUndo.apply(_this, [target, selector].concat(__slice.call(args)));
        };
      };
      for (selector in target) {
        if (hasGetter(target, selector)) {
          continue;
        }
        if (typeof target[selector] !== 'function') {
          continue;
        }
        _fn(selector);
      }
      return proxy;
    };

    return UndoManager;

  })();

  module.exports = UndoManager;

}).call(this);
}};
FieldKit = require('index.js');
}());