// Generated by CoffeeScript 1.6.2
(function() {
  var UndoManager, hasGetter,
    __slice = [].slice;

  hasGetter = function(object, property) {
    var _ref, _ref1, _ref2;

    if (object != null ? (_ref = object.constructor) != null ? _ref.prototype : void 0 : void 0) {
      if ((_ref1 = Object.getOwnPropertyDescriptor(object.constructor.prototype, property)) != null ? _ref1.get : void 0) {
        return true;
      }
    }
    return ((_ref2 = Object.getOwnPropertyDescriptor(object, property)) != null ? _ref2.get : void 0) != null;
  };

  UndoManager = (function() {
    UndoManager.prototype._undos = null;

    UndoManager.prototype._redos = null;

    UndoManager.prototype._isUndoing = false;

    UndoManager.prototype._isRedoing = false;

    function UndoManager() {
      this._undos = [];
      this._redos = [];
    }

    UndoManager.prototype.canUndo = function() {
      return this._undos.length !== 0;
    };

    UndoManager.prototype.canRedo = function() {
      return this._redos.length !== 0;
    };

    UndoManager.prototype.isUndoing = function() {
      return this._isUndoing;
    };

    UndoManager.prototype.isRedoing = function() {
      return this._isRedoing;
    };

    UndoManager.prototype.registerUndo = function() {
      var args, selector, target;

      target = arguments[0], selector = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      if (this._isUndoing) {
        this._appendRedo.apply(this, [target, selector].concat(__slice.call(args)));
      } else {
        if (!this._isRedoing) {
          this._redos.length = 0;
        }
        this._appendUndo.apply(this, [target, selector].concat(__slice.call(args)));
      }
      return null;
    };

    UndoManager.prototype._appendUndo = function() {
      var args, selector, target;

      target = arguments[0], selector = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      return this._undos.push({
        target: target,
        selector: selector,
        args: args
      });
    };

    UndoManager.prototype._appendRedo = function() {
      var args, selector, target;

      target = arguments[0], selector = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      return this._redos.push({
        target: target,
        selector: selector,
        args: args
      });
    };

    UndoManager.prototype.undo = function() {
      var args, selector, target, _ref;

      if (!this.canUndo()) {
        throw new Error('there are no registered undos');
      }
      _ref = this._undos.pop(), target = _ref.target, selector = _ref.selector, args = _ref.args;
      this._isUndoing = true;
      target[selector].apply(target, args);
      this._isUndoing = false;
      return null;
    };

    UndoManager.prototype.redo = function() {
      var args, selector, target, _ref;

      if (!this.canRedo()) {
        throw new Error('there are no registered redos');
      }
      _ref = this._redos.pop(), target = _ref.target, selector = _ref.selector, args = _ref.args;
      this._isRedoing = true;
      target[selector].apply(target, args);
      this._isRedoing = false;
      return null;
    };

    UndoManager.prototype.proxyFor = function(target) {
      var proxy, selector, _fn,
        _this = this;

      proxy = {};
      _fn = function(selector) {
        return proxy[selector] = function() {
          var args;

          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return _this.registerUndo.apply(_this, [target, selector].concat(__slice.call(args)));
        };
      };
      for (selector in target) {
        if (hasGetter(target, selector)) {
          continue;
        }
        if (typeof target[selector] !== 'function') {
          continue;
        }
        _fn(selector);
      }
      return proxy;
    };

    return UndoManager;

  })();

  module.exports = UndoManager;

}).call(this);
