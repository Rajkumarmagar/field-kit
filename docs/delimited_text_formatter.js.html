<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: delimited_text_formatter.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: delimited_text_formatter.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*! jshint esnext:true, undef:true, unused:true */

import Formatter from './formatter';

/**
 * A generic delimited formatter.
 *
 * @extends Formatter
 */
class DelimitedTextFormatter extends Formatter {
  /**
   * @param {string=} delimiter
   * @param {boolean=} isLazy
   * @throws {Error} delimiter must have just one character
   */
  constructor(delimiter=this.delimiter, isLazy=false) {
    if (delimiter === null || delimiter === undefined || delimiter.length !== 1) {
      throw new Error('delimiter must have just one character');
    }
    this.delimiter = delimiter;

    // If the formatter is lazy, delimiter will not be added until input has gone
    // past the delimiter index. Useful for 'optional' extension, like zip codes.
    // 94103  ->  type '1'  ->  94103-1
    this.isLazy = isLazy;
  }

  /**
   * Determines the delimiter character at the given index.
   *
   * @param {number} index
   * @returns {?string}
   */
  delimiterAt(index) {
    if (!this.hasDelimiterAtIndex(index)) {
      return null;
    }
    return this.delimiter;
  }

  /**
   * Determines whether the given character is a delimiter.
   *
   * @param {string} chr
   * @returns {boolean}
   */
  isDelimiter(chr) {
    return chr === this.delimiter;
  }

  /**
   * Formats the given value by adding delimiters where needed.
   *
   * @param {?string} value
   * @returns {string}
   */
  format(value) {
    return this._textFromValue(value);
  }

  /**
   * Formats the given value by adding delimiters where needed.
   *
   * @param {?string} value
   * @returns {string}
   * @private
   */
  _textFromValue(value) {
    if (!value) { return ''; }

    var result = '';
    var delimiter;
    var maximumLength = this.maximumLength;

    for (var i = 0, l = value.length; i &lt; l; i++) {
      while ((delimiter = this.delimiterAt(result.length))) {
        result += delimiter;
      }
      result += value[i];
      if (!this.isLazy) {
        while ((delimiter = this.delimiterAt(result.length))) {
          result += delimiter;
        }
      }
    }

    if (maximumLength !== undefined &amp;&amp; maximumLength !== null) {
      return result.slice(0, maximumLength);
    } else {
      return result;
    }
  }

  /**
   * Parses the given text by removing delimiters.
   *
   * @param {?string} text
   * @returns {string}
   */
  parse(text) {
    return this._valueFromText(text);
  }

  /**
   * Parses the given text by removing delimiters.
   *
   * @param {?string} text
   * @returns {string}
   * @private
   */
  _valueFromText(text) {
    if (!text) { return ''; }
    var result = '';
    for (var i = 0, l = text.length; i &lt; l; i++) {
      if (!this.isDelimiter(text[i])) {
        result += text[i];
      }
    }
    return result;
  }

  /**
   * Determines whether the given change should be allowed and, if so, whether
   * it should be altered.
   *
   * @param {TextFieldStateChange} change
   * @param {function(string)} error
   * @returns {boolean}
   */
  isChangeValid(change, error) {
    if (!super(change, error)) {
      return false;
    }

    var newText = change.proposed.text;
    var range = change.proposed.selectedRange;
    var hasSelection = range.length !== 0;

    var startMovedLeft = range.start &lt; change.current.selectedRange.start;
    var startMovedRight = range.start > change.current.selectedRange.start;
    var endMovedLeft = (range.start + range.length) &lt; (change.current.selectedRange.start + change.current.selectedRange.length);
    var endMovedRight = (range.start + range.length) > (change.current.selectedRange.start + change.current.selectedRange.length);

    var startMovedOverADelimiter = startMovedLeft &amp;&amp; this.hasDelimiterAtIndex(range.start) ||
                                    startMovedRight &amp;&amp; this.hasDelimiterAtIndex(range.start - 1);
    var endMovedOverADelimiter = endMovedLeft &amp;&amp; this.hasDelimiterAtIndex(range.start + range.length) ||
                                  endMovedRight &amp;&amp; this.hasDelimiterAtIndex(range.start + range.length - 1);

    if (this.isDelimiter(change.deleted.text)) {
      var newCursorPosition = change.deleted.start - 1;
      // delete any immediately preceding delimiters
      while (this.isDelimiter(newText.charAt(newCursorPosition))) {
        newText = newText.substring(0, newCursorPosition) + newText.substring(newCursorPosition + 1);
        newCursorPosition--;
      }
      // finally delete the real character that was intended
      newText = newText.substring(0, newCursorPosition) + newText.substring(newCursorPosition + 1);
    }

    // adjust the cursor / selection
    if (startMovedLeft &amp;&amp; startMovedOverADelimiter) {
      // move left over any immediately preceding delimiters
      while (this.delimiterAt(range.start - 1)) {
        range.start--;
        range.length++;
      }
      // finally move left over the real intended character
      range.start--;
      range.length++;
    }

    if (startMovedRight) {
      // move right over any delimiters found on the way, including any leading delimiters
      for (var i = change.current.selectedRange.start; i &lt; range.start + range.length; i++) {
        if (this.delimiterAt(i)) {
          range.start++;
          if(range.length > 0) {
            range.length--;
          }
        }
      }

      while (this.delimiterAt(range.start)) {
        range.start++;
        range.length--;
      }
    }

    if (hasSelection) { // Otherwise, the logic for the range start takes care of everything.
      if (endMovedOverADelimiter) {
        if (endMovedLeft) {
          // move left over any immediately preceding delimiters
          while (this.delimiterAt(range.start + range.length - 1)) {
            range.length--;
          }
          // finally move left over the real intended character
          range.length--;
        }

        if (endMovedRight) {
          // move right over any immediately following delimiters
          while (this.delimiterAt(range.start + range.length)) {
            range.length++;
          }
          // finally move right over the real intended character
          range.length++;
        }
      }

      // trailing delimiters in the selection
      while (this.hasDelimiterAtIndex(range.start + range.length - 1)) {
        if (startMovedLeft || endMovedLeft) {
          range.length--;
        } else {
          range.length++;
        }
      }

      while (this.hasDelimiterAtIndex(range.start)) {
        if (startMovedRight || endMovedRight) {
          range.start++;
          range.length--;
        } else {
          range.start--;
          range.length++;
        }
      }
    } else {
      range.length = 0;
    }

    var result = true;

    var value = this._valueFromText(newText, function(...args) {
      result = false;
      error(...args);
    });

    if (result) {
      change.proposed.text = this._textFromValue(value);
    }

    return result;
  }
}

export default DelimitedTextFormatter;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Classes</h3><ul><li><a href="AdaptiveCardFormatter.html">AdaptiveCardFormatter</a></li><li><a href="AmexCardFormatter.html">AmexCardFormatter</a></li><li><a href="CardTextField.html">CardTextField</a></li><li><a href="DefaultCardFormatter.html">DefaultCardFormatter</a></li><li><a href="DelimitedTextFormatter.html">DelimitedTextFormatter</a></li><li><a href="ExpiryDateField.html">ExpiryDateField</a></li><li><a href="ExpiryDateFormatter.html">ExpiryDateFormatter</a></li><li><a href="Formatter.html">Formatter</a></li><li><a href="NumberFormatter.html">NumberFormatter</a></li><li><a href="PhoneFormatter.html">PhoneFormatter</a></li><li><a href="SocialSecurityNumberFormatter.html">SocialSecurityNumberFormatter</a></li><li><a href="TextField.html">TextField</a></li><li><a href="UndoManager.html">UndoManager</a></li></ul><h3>Namespaces</h3><ul><li><a href="CurrencyDefaults.html">CurrencyDefaults</a></li><li><a href="FieldKit.html">FieldKit</a></li><li><a href="KEYS.html">KEYS</a></li><li><a href="LocaleDefaults.html">LocaleDefaults</a></li><li><a href="RegionDefaults.html">RegionDefaults</a></li><li><a href="StyleDefaults.html">StyleDefaults</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-dev</a> on Wed Dec 17 2014 19:59:08 GMT-0500 (EST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
