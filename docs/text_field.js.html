<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: text_field.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: text_field.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/* jshint browser:true, esnext:true, undef:true, unused:true */
/* global console, KeyboardEvent */

import Formatter from './formatter';
import UndoManager from './undo_manager';
import { bind } from './utils';
import Caret from './caret';

/**
 * Simulates input behavior.
 *
 * @external InputSim
 * @see https://github.com/iamJoeTaylor/input-sim
 */
import {Input, KEYS, keyBindingsForPlatform} from 'input-sim';

/**
 * TextField is the simplest input and the base for more complex
 * types to inherit.
 *
 * @extends external:InputSim.Input
 */
class TextField extends Input {
  /**
   * Sets up the initial properties of the TextField and
   * sets  up the event listeners
   *
   * @param {HTMLElement} element
   * @param {Formatter} formatter
   */
  constructor(element, formatter) {
    var caret = Caret.get(element);
    if (typeof element.get === 'function') {
      console.warn(
        'DEPRECATION: FieldKit.TextField instances should no longer be ' +
        'created with a jQuery-wrapped element.'
      );
      element = element.get(0);
    }
    this.element = element;
    this._formatter = formatter;
    this._enabled = true;
    this._manualCaret = { start: 0, end: 0 };
    this._placeholder = null;
    this._disabledPlaceholder = null;
    this._focusedPlaceholder = null;
    this._unfocusedPlaceholder = null;
    this._isDirty = false;
    this._valueOnFocus = '';
    this._blur = bind(this._blur, this);
    this._focus = bind(this._focus, this);
    this._click = bind(this._click, this);
    this._paste = bind(this._paste, this);
    this._keyUp = bind(this._keyUp, this);
    this._keyPress = bind(this._keyPress, this);
    this._keyDown = bind(this._keyDown, this);
    if (element['field-kit-text-field']) {
      throw new Error('already attached a TextField to this element');
    } else {
      element['field-kit-text-field'] = this;
    }
    element.addEventListener('keydown', this._keyDown);
    element.addEventListener('keypress', this._keyPress);
    element.addEventListener('keyup', this._keyUp);
    element.addEventListener('click', this._click);
    element.addEventListener('paste', this._paste);
    element.addEventListener('focus', this._focus);
    element.addEventListener('blur', this._blur);

    var window = element.ownerDocument.defaultView;

    /**
     * Fixes caret bug (Android) that caused the input
     * to place inserted characters in the wrong place
     * Expected: 1234 5678|  =>  1234 5678 9|
     * Bug: 1234 5678|  =>  1234 5679| 8
     *
     * @private
     */
    this._needsManualCaret = window.navigator.userAgent.toLowerCase().indexOf('android') > -1;

    super(element.value, {
      start: caret.start,
      length: caret.end - caret.start
    });
  }


  /**
   * **** Public Events ****
   */

  /**
   * Called when the user has changed the text of the field. Can be used in
   * subclasses to perform actions suitable for this event.
   *
   * @private
   */
  textDidChange() {}

  /**
   * Called when the user has in some way declared that they are done editing,
   * such as leaving the field or perhaps pressing enter. Can be used in
   * subclasses to perform actions suitable for this event.
   *
   * @private
   */
  textFieldDidEndEditing() {}

  /**
   * Performs actions necessary for beginning editing.
   *
   * @private
   */
  textFieldDidBeginEditing() {}


  /**
   * **** Private Events ****
   */

  /**
   * Performs actions necessary for text change.
   *
   * @private
   */
  _textDidChange() {
    var delegate = this._delegate;
    this.textDidChange();
    if (delegate &amp;&amp; typeof delegate.textDidChange === 'function') {
      delegate.textDidChange(this);
    }

    // manually fire the HTML5 input event
    this._fireEvent('input');
  }

  /**
   * Performs actions necessary for ending editing.
   *
   * @private
   */
  _textFieldDidEndEditing() {
    var delegate = this._delegate;
    this.textFieldDidEndEditing();
    if (delegate &amp;&amp; typeof delegate.textFieldDidEndEditing === 'function') {
      delegate.textFieldDidEndEditing(this);
    }

    // manually fire the HTML5 change event, only when a change has been made since focus
    if (this._isDirty &amp;&amp; (this._valueOnFocus !== this.element.value)) {
      this._fireEvent('change');
    }

    // reset the dirty property
    this._isDirty = false;
    this._valueOnFocus = '';
  }

  /**
   * Performs actions necessary for beginning editing.
   *
   * @private
   */
  _textFieldDidBeginEditing() {
    var delegate = this._delegate;
    this.textFieldDidBeginEditing();
    if (delegate &amp;&amp; typeof delegate.textFieldDidBeginEditing === 'function') {
      delegate.textFieldDidBeginEditing(this);
    }
  }


  /**
   * **** Public Methods ****
   */

  /**
   * Gets the current delegate for this text field.
   *
   * @returns {TextFieldDelegate}
   */
  delegate() {
    return this._delegate;
  }

  /**
   * Sets the current delegate for this text field.
   *
   * @param {TextFieldDelegate} delegate
   */
  setDelegate(delegate) {
    this._delegate = delegate;
  }

  /**
   * Tears down FieldKit
   */
  destroy() {
    var element = this.element;
    element.removeEventListener('keydown', this._keyDown);
    element.removeEventListener('keypress', this._keyPress);
    element.removeEventListener('keyup', this._keyUp);
    element.removeEventListener('click', this._click);
    element.removeEventListener('paste', this._paste);
    element.removeEventListener('focus', this._focus);
    element.removeEventListener('blur', this._blur);
    delete element['field-kit-text-field'];
  }

  /**
   * Gets the current formatter. Formatters are used to translate between text
   * and value properties of the field.
   *
   * @returns {Formatter}
   */
  formatter() {
    if (!this._formatter) {
      this._formatter = new Formatter();
      var maximumLengthString = this.element.getAttribute('maxlength');
      if (maximumLengthString !== undefined &amp;&amp; maximumLengthString !== null) {
        this._formatter.maximumLength = parseInt(maximumLengthString, 10);
      }
    }

    return this._formatter;
  }

  /**
   * Sets the current formatter.
   *
   * @param {Formatter} formatter
   */
  setFormatter(formatter) {
    var value = this.value();
    this._formatter = formatter;
    this.setValue(value);
  }

  /**
   * Builds a change instance and formats the change to see if it's valid
   *
   * @param   { object} current
   * @param   { object} proposed
   * @returns { false|object} false if change doesn't have changes or change isn't valid. Change object if it is.
   */
  hasChangesAndIsValid(current, proposed) {
    var change = new TextFieldStateChange(this);
    var error = errorType => {
      var delegate = this.delegate();
      if (delegate) {
        if (typeof delegate.textFieldDidFailToValidateChange === 'function') {
          delegate.textFieldDidFailToValidateChange(this, change, errorType);
        }
      }
    };
    change.current = {text: current.text, selectedRange: current.selectedRange};
    change.proposed = {text: proposed.text, selectedRange: proposed.selectedRange};
    if (change.hasChanges() &amp;&amp; this.formatter().isChangeValid(change, error)) {
      return change;
    }
    return false;
  }

  /**
   * Handles a key event could be trying to end editing.
   *
   */
  insertNewline() {
    this._textFieldDidEndEditing();
    this._didEndEditingButKeptFocus = true;
  }

  /**
   * Debug support
   *
   * @returns {string}
   */
  inspect() {
    return '#&lt;TextField text="' + this.text() + '">';
  }

  /**
   * Replaces the current selection with text from the given pasteboard.
   *
   * @param {DataTransfer} pasteboard
   */
  readSelectionFromPasteboard(pasteboard) {
    var range, text;
    text = pasteboard.getData('Text');
    this.replaceSelection(text);
    range = this.selectedRange();
    range.start += range.length;
    range.length = 0;
    this.setSelectedRange(range);
  }

  /**
   * Replaces the characters within the selection with given text.
   *
   * @example
   *     // 12|34567|8
   *     replaceStringSelection('00')
   *     // 12|00|8
   *
   * @param   {string} replacement
   * @param   {string} text
   * @param   {object} {start: number, length: number}
   * @returns {string}
   */
  replaceStringSelection(replacement, text, range) {
    var end = range.start + range.length;
    return text.substring(0, range.start) + replacement + text.substring(end);
  }

  /**
   * Checks changes after invoking the passed function for validity and rolls
   * them back if the changes turned out to be invalid.
   *
   * @returns {Object} whatever object `callback` returns
   */
  rollbackInvalidChanges(callback) {
    var result = null;
    var errorType = null;
    var change = TextFieldStateChange.build(this, function() {
      result = callback();
    });
    var error = function(type) { errorType = type; };
    if (change.hasChanges()) {
      var formatter = this.formatter();
      if (formatter &amp;&amp; typeof formatter.isChangeValid === 'function') {
        if (!this._isDirty) {
          this._valueOnFocus = change.current.text || '';
          this._isDirty = true;
        }
        if (formatter.isChangeValid(change, error)) {
          change.recomputeDiff();
          this.setText(change.proposed.text);
          this.setSelectedRange(change.proposed.selectedRange);
        } else {
          var delegate = this.delegate();
          if (delegate) {
            if (typeof delegate.textFieldDidFailToValidateChange === 'function') {
              delegate.textFieldDidFailToValidateChange(this, change, errorType);
            }
          }
          this.setText(change.current.text);
          this.setSelectedRange(change.current.selectedRange);
          return result;
        }
      }
      if (change.inserted.text.length || change.deleted.text.length) {
        this.undoManager().proxyFor(this)._applyChangeFromUndoManager(change);
        this._textDidChange();
      }
    }
    return result;
  }

  /**
   * Gets the object value. This is the value that should be considered the
   * 'real' value of the field.
   *
   * @returns {Object}
   */
  value() {
    var text = this.text();
    var delegate = this.delegate();
    var formatter = this.formatter();
    if (!formatter) { return text; }

    return formatter.parse(text, (errorType) => {
      if (delegate) {
        if (typeof delegate.textFieldDidFailToParseString === 'function') {
          delegate.textFieldDidFailToParseString(this, text, errorType);
        }
      }
    });
  }

  /**
   * Sets the object value of the field.
   *
   * @param {string} value
   */
  setValue(value) {
    if (this._formatter) {
      value = this._formatter.format(value);
    }
    this.setText('' + value);
  }


  /**
   * **** InputSim Overrides ****
   */

  /**
   * Gets the formatted text value. This is the same as the value of the
   * underlying input element.
   *
   * @augments external:InputSim.Input#text
   * @returns {string}
   */
  text() {
    return this.element.value;
  }

  /**
   * Sets the formatted text value. This generally should not be used. Instead,
   * use the value setter.
   *
   * @augments external:InputSim.Input#setText
   * @param {string} text
   */
  setText(text) {
    this.element.value = text;
  }

  /**
   * Gets the range of the current selection.
   *
   * @augments external:InputSim.Input#selectedRange
   * @returns {Object} {start: number, length: number}
   */
  selectedRange() {
    var caret = this._needsManualCaret ?
        this._manualCaret :
        Caret.get(this.element);

    return {
      start: caret.start,
      length: caret.end - caret.start
    };
  }

  /**
   * Sets the range of the current selection and the selection affinity.
   *
   * @augments external:InputSim.Input#setSelectedRangeWithAffinity
   * @param {{start: number, length: number}} range
   * @param {Affinity} affinity
   */
  setSelectedRangeWithAffinity(range, affinity) {
    var newRange = super.setSelectedRangeWithAffinity(range, affinity);
    var caret = {
      start: newRange.start,
      end: newRange.start + newRange.length
    };
    this._manualCaret = caret;
    Caret.set(this.element, caret.start, caret.end);
    this.selectionAffinity = range.length === 0 ? null : affinity;
  }


  /**
   * **** Undo Support ****
   */

  /**
   * Gets whether this text field records undo actions with its undo manager.
   *
   * @returns {boolean}
   */
  allowsUndo() {
    return this._allowsUndo;
  }

  /**
   * Sets whether this text field records undo actions with its undo manager.
   *
   * @param {boolean} allowsUndo
   */
  setAllowsUndo(allowsUndo) {
    this._allowsUndo = allowsUndo;
  }

  /**
   * Triggers a redo in the underlying UndoManager, if applicable.
   *
   * @param {Event} event
   */
  redo(event) {
    if (this.undoManager().canRedo()) {
      this.undoManager().redo();
    }
    event.preventDefault();
  }

  /**
   * Triggers an undo in the underlying UndoManager, if applicable.
   *
   * @param {Event} event
   */
  undo(event) {
    if (this.undoManager().canUndo()) {
      this.undoManager().undo();
    }
    event.preventDefault();
  }

  /**
   * Gets the UndoManager for this text field.
   *
   * @returns {UndoManager}
   */
  undoManager() {
    return this._undoManager || (this._undoManager = new UndoManager());
  }


  /**
   * **** Enabled/disabled support *****
   */

  /**
   * Removes focus from this field if it has focus.
   */
  becomeFirstResponder() {
    this.element.focus();
    this.rollbackInvalidChanges(() => {
      this.element.select();
      this._syncPlaceholder();
    });
  }

  /**
   * Determines whether this field has focus.
   *
   * @returns {boolean} true if this field has focus
   */
  hasFocus() {
    return this.element.ownerDocument.activeElement === this.element;
  }

  /**
   * Determines whether this field is enabled or disabled.
   *
   * @returns {boolean} true if this field is enabled
   */
  isEnabled() {
    return this._enabled;
  }

  /**
   * Sets whether this text field is enabled
   * and syncs the placeholder to match
   *
   * @param {boolean} enabled
   */
  setEnabled(enabled) {
    this._enabled = enabled;
    this._syncPlaceholder();
  }

  /**
   * Removes focus from this field if it has focus.
   *
   * @param {Event} event
   */
  resignFirstResponder(event) {
    if (event !== undefined &amp;&amp; event !== null) {
      event.preventDefault();
    }
    this.element.blur();
    this._syncPlaceholder();
  }


  /**
   * **** Placeholder support ****
   */

  /**
   * Gets the disabled placeholder if one
   * has been set.
   *
   * @returns {string}
   */
  disabledPlaceholder() {
    return this._disabledPlaceholder;
  }

  /**
   * Sets the disabled placeholder.
   *
   * @param {string} disabledPlaceholder
   */
  setDisabledPlaceholder(disabledPlaceholder) {
    this._disabledPlaceholder = disabledPlaceholder;
    this._syncPlaceholder();
  }

  /**
   * Gets the focused placeholder if one
   * has been set.
   *
   * @returns {string}
   */
  focusedPlaceholder() {
    return this._focusedPlaceholder;
  }

  /**
   * Sets the focused placeholder.
   *
   * @param {string} focusedPlaceholder
   */
  setFocusedPlaceholder(focusedPlaceholder) {
    this._focusedPlaceholder = focusedPlaceholder;
    this._syncPlaceholder();
  }

  /**
   * Gets the placeholder if one has
   * been set.
   *
   * @TODO Does this do anything?
   *
   * @returns {string}
   */
  placeholder() {
    return this._placeholder;
  }

  /**
   * Sets the placeholder.
   *
   * @param {string} placeholder
   */
  setPlaceholder(placeholder) {
    this._placeholder = placeholder;
    this.element.setAttribute('placeholder', this._placeholder);
  }

  /**
   * Gets the unfocused placeholder if one
   * has been set.
   *
   * @returns {string}
   */
  unfocusedPlaceholder() {
    return this._unfocusedPlaceholder;
  }

  /**
   * Sets the unfocused placeholder.
   *
   * @param {string} unfocusedPlaceholder
   */
  setUnfocusedPlaceholder(unfocusedPlaceholder) {
    this._unfocusedPlaceholder = unfocusedPlaceholder;
    this._syncPlaceholder();
  }


  /**
   * **** Private Methods ****
   */

  /**
   * Applies the given change as an undo/redo.
   *
   * @param {Object} change object with current and proposed properties
   * @private
   */
  _applyChangeFromUndoManager(change) {
    this.undoManager().proxyFor(this)._applyChangeFromUndoManager(change);

    if (this.undoManager().isUndoing()) {
      this.setText(change.current.text);
      this.setSelectedRange(change.current.selectedRange);
    } else {
      this.setText(change.proposed.text);
      this.setSelectedRange(change.proposed.selectedRange);
    }

    this._textDidChange();
  }

  /**
   * Builds the key bindings for platform
   *
   * @augments external:InputSim.Input#_buildKeybindings
   * @private
   */
  _buildKeybindings() {
    var doc = this.element.ownerDocument;
    var win = doc.defaultView || doc.parentWindow;
    var userAgent = win.navigator.userAgent;
    var osx = /^Mozilla\/[\d\.]+ \(Macintosh/.test(userAgent);
    this._bindings = keyBindingsForPlatform(osx ? 'OSX' : 'Default');
  }

  /**
   * Handles clicks by resetting the selection affinity.
   *
   * @private
   */
  _click() {
    this._manualCaret = Caret.get(this.element);
    this._selectedRange = {
      start: this._manualCaret.start,
      length: this._manualCaret.end - this._manualCaret.start
    };
    this.selectionAffinity = null;
  }

  /**
   * Fires event on the element
   *
   * @param {string} eventType
   * @private
   */
  _fireEvent(eventType) {
    var document = this.element.ownerDocument;
    var window = document.defaultView;
    if (typeof window.CustomEvent === 'function') {
      this.element.dispatchEvent(new window.CustomEvent(eventType, {}));
    } else {
      var event = document.createEvent('Event');
      event.initEvent(eventType, false, false);
      this.element.dispatchEvent(event);
    }
  }

  /**
   * Handles gaining focus. This method delegates to other methods, and syncs
   * the placeholder appropriately.
   *
   * @private
   */
  _focus() {
    this._textFieldDidBeginEditing();
    this._syncPlaceholder();
  }

  /**
   * Handles losing focus. This method delegates to other methods, and syncs the
   * placeholder appropriately.
   *
   * @private
   */
  _blur() {
    this._textFieldDidEndEditing();
    this._syncPlaceholder();
  }

  /**
   * Handles keyDown events. This method essentially just delegates to other,
   * more semantic, methods based on the modifier keys and the pressed key of the
   * event.
   *
   * @param {Event} event
   * @private
   */
  _keyDown(event) {
    if (this._didEndEditingButKeptFocus) {
      this._textFieldDidBeginEditing();
      this._didEndEditingButKeptFocus = false;
    }

    var action = this._bindings.actionForEvent(event);
    if (action) {
      switch (action) {
        case 'undo':
        case 'redo':
          this[action](event);
          break;

        default:
          this.rollbackInvalidChanges(() => this[action](event));
          break;
      }
    }
  }

  /**
   * Handles inserting characters based on the typed key.
   *
   * @param {Event} event
   * @private
   */
  _keyPress(event) {
    var keyCode = event.keyCode;
    if (!event.metaKey &amp;&amp; !event.ctrlKey &amp;&amp;
      keyCode !== KEYS.ENTER &amp;&amp;
      keyCode !== KEYS.TAB &amp;&amp;
      keyCode !== KEYS.BACKSPACE &amp;&amp;
      event.charCode !== 0
     ) {

      var newText = String.fromCharCode(event.charCode || event.keyCode);
      var current = {
        text: this.text(),
        selectedRange: this.selectedRange()
      };
      var proposed = {
        text: this.replaceStringSelection(newText, current.text, current.selectedRange),
        selectedRange: { start: current.selectedRange.start + 1, length: 0 }
      };
      var change = this.hasChangesAndIsValid(current, proposed);
      // HACK(JoeTaylor) Use Browser native input when the formatter
      // would not make a difference
      if (change &amp;&amp;
        change.proposed.text === proposed.text &amp;&amp;
        change.proposed.selectedRange.start === proposed.selectedRange.start &amp;&amp;
        change.proposed.selectedRange.length === proposed.selectedRange.length &amp;&amp;
        event instanceof KeyboardEvent
      ) {
        this.undoManager().proxyFor(this)._applyChangeFromUndoManager(change);
      } else {
        event.preventDefault();
        this.rollbackInvalidChanges(() => this.insertText(newText));
      }
    } else if (!event.metaKey &amp;&amp; !event.ctrlKey &amp;&amp;
      keyCode !== KEYS.ENTER &amp;&amp;
      keyCode !== KEYS.TAB &amp;&amp;
      keyCode !== KEYS.BACKSPACE &amp;&amp;
      event.charCode === 0
    ) {
      event.preventDefault();
    }
  }

  /**
   * Handles keyup events.
   *
   * @param {Event} event
   * @private
   */
  _keyUp(event) {
    this.rollbackInvalidChanges(() => {
      if (event.keyCode === KEYS.TAB) {
        this.selectAll(event);
      }
    });
  }


  /**
   * Handles paste events.
   *
   * @param {Event} event
   * @private
   */
  _paste(event) {
    event.preventDefault();
    this.rollbackInvalidChanges(() => {
      this.readSelectionFromPasteboard(event.clipboardData);
    });
  }

  /**
   * @private
   */
  _syncPlaceholder() {
    if (!this._enabled) {
      var disabledPlaceholder = this._disabledPlaceholder;
      if (disabledPlaceholder !== undefined &amp;&amp; disabledPlaceholder !== null) {
        this.setPlaceholder(disabledPlaceholder);
      }
    } else if (this.hasFocus()) {
      var focusedPlaceholder = this._focusedPlaceholder;
      if (focusedPlaceholder !== undefined &amp;&amp; focusedPlaceholder !== null) {
        this.setPlaceholder(focusedPlaceholder);
      }
    } else {
      var unfocusedPlaceholder = this._unfocusedPlaceholder;
      if (unfocusedPlaceholder !== undefined &amp;&amp; unfocusedPlaceholder !== null) {
        this.setPlaceholder(unfocusedPlaceholder);
      }
    }
  }
}

/**
 * Helps calculate the changes after an event on a FieldKit.TextField.
 *
 * @private
 */
class TextFieldStateChange {
  /**
   * @param {TextField} field
   */
  constructor(field) {
    this.field = field;
  }

  /**
   * Determines whether this field has changes.
   *
   * @returns {boolean} true if either the current text doesn't match the proposed text
   *    or the current selection range doesn't match the proposed selection range
   */
  hasChanges() {
    this.recomputeDiff();
    return this.current.text !== this.proposed.text ||
      this.current.selectedRange.start !== this.proposed.selectedRange.start ||
      this.current.selectedRange.length !== this.proposed.selectedRange.length;
  }

  /**
   * Updates {TextFieldStateChange} inserted and {TextFieldStateChange} deleted
   * based on proposed and current
   */
  recomputeDiff() {
    if (this.proposed.text !== this.current.text) {
      var ctext = this.current.text;
      var ptext = this.proposed.text;
      var sharedPrefixLength = 0;
      var sharedSuffixLength = 0;
      var minTextLength = Math.min(ctext.length, ptext.length);
      var i;

      for (i = 0; i &lt; minTextLength; i++) {
        if (ptext[i] === ctext[i]) {
          sharedPrefixLength = i + 1;
        } else {
          break;
        }
      }

      for (i = 0; i &lt; minTextLength - sharedPrefixLength; i++) {
        if (ptext[ptext.length - 1 - i] === ctext[ctext.length - 1 - i]) {
          sharedSuffixLength = i + 1;
        } else {
          break;
        }
      }

      var inserted = {
        start: sharedPrefixLength,
        end: ptext.length - sharedSuffixLength
      };
      var deleted = {
        start: sharedPrefixLength,
        end: ctext.length - sharedSuffixLength
      };
      inserted.text = ptext.substring(inserted.start, inserted.end);
      deleted.text = ctext.substring(deleted.start, deleted.end);
      this.inserted = inserted;
      this.deleted = deleted;
    } else {
      this.inserted = {
        start: this.proposed.selectedRange.start,
        end: this.proposed.selectedRange.start + this.proposed.selectedRange.length,
        text: ''
      };
      this.deleted = {
        start: this.current.selectedRange.start,
        end: this.current.selectedRange.start + this.current.selectedRange.length,
        text: ''
      };
    }
  }
}

/**
 * Builds a new {TextFieldStateChange} that will allow you to
 * compute differences, and see the current vs proposed changes.
 *
 * @param {TextField} field
 * @param {Function} callback called when you want changes to the field
 *    take place. Current will be calculated before this callback.
 *    Proposed will be calculated after this callback.
 *
 * @returns {Object} change object with current and proposed properties
 */
TextFieldStateChange.build = function(field, callback) {
  var change = new this(field);
  change.current = {
    text: field.text(),
    selectedRange: field.selectedRange()
  };
  callback();
  change.proposed = {
    text: field.text(),
    selectedRange: field.selectedRange()
  };
  change.recomputeDiff();
  return change;
};

export default TextField;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Externals</h3><ul><li><a href="external-InputSim.html">InputSim</a></li></ul><h3>Classes</h3><ul><li><a href="AdaptiveCardFormatter.html">AdaptiveCardFormatter</a></li><li><a href="AmexCardFormatter.html">AmexCardFormatter</a></li><li><a href="CardTextField.html">CardTextField</a></li><li><a href="DefaultCardFormatter.html">DefaultCardFormatter</a></li><li><a href="DelimitedTextFormatter.html">DelimitedTextFormatter</a></li><li><a href="ExpiryDateField.html">ExpiryDateField</a></li><li><a href="ExpiryDateFormatter.html">ExpiryDateFormatter</a></li><li><a href="Formatter.html">Formatter</a></li><li><a href="NumberFormatter.html">NumberFormatter</a></li><li><a href="PhoneFormatter.html">PhoneFormatter</a></li><li><a href="SocialSecurityNumberFormatter.html">SocialSecurityNumberFormatter</a></li><li><a href="TextField.html">TextField</a></li><li><a href="UndoManager.html">UndoManager</a></li></ul><h3>Namespaces</h3><ul><li><a href="CurrencyDefaults.html">CurrencyDefaults</a></li><li><a href="FieldKit.html">FieldKit</a></li><li><a href="KEYS.html">KEYS</a></li><li><a href="LocaleDefaults.html">LocaleDefaults</a></li><li><a href="RegionDefaults.html">RegionDefaults</a></li><li><a href="StyleDefaults.html">StyleDefaults</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-dev</a> on Wed Jul 29 2015 16:54:05 GMT-0700 (PDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
